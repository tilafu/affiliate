const pool = require('../config/db');
const { v4: uuidv4 } = require('uuid');
const logger = require('../logger');
const { calculateCommission } = require('../utils/commission');
const { logDriveOperation } = require('../utils/driveLogger');
const driveProgressService = require('../services/driveProgressService');

// --- Helper Functions ---
async function getUserDriveInfo(userId) {
  const userResult = await pool.query('SELECT tier FROM users WHERE id = $1', [userId]);
  if (userResult.rows.length === 0) throw new Error('User not found');
  const tier = userResult.rows[0].tier || 'bronze';
  const accountResult = await pool.query(
    'SELECT balance FROM accounts WHERE user_id = $1 AND type = \'main\'',
    [userId]
  );
  const balance = accountResult.rows.length > 0 ? parseFloat(accountResult.rows[0].balance) : 0;
  return { tier, balance };
}

async function getAvailableProduct(userId, tier, balance) {
  const query = 'SELECT * FROM products WHERE is_active = true ORDER BY RANDOM() LIMIT 1';
  const productsResult = await pool.query(query);
  if (productsResult.rows.length === 0) return null;
  return productsResult.rows[0];
}

// --- Controller Functions ---
const startDrive = async (req, res) => {
    const userId = req.user.id;
    logger.debug(`Entering startDrive for user ID: ${userId}`); // Added debug log

    try {
        // Check if the user already has an active drive session
        logger.debug(`Checking for existing active session for user ID: ${userId}`); // Added debug log
        const existingSession = await pool.query(
            'SELECT id FROM drive_sessions WHERE user_id = $1 AND status = \'active\'',
            [userId]
        );

        if (existingSession.rows.length > 0) {
            const activeSessionId = existingSession.rows[0].id;
            logger.info(`Active drive session ${activeSessionId} found for user ID: ${userId}. Returning session details.`); // Changed to info
            
            const sessionDetailsResult = await pool.query(
                `SELECT 
                    ds.id AS drive_session_id, 
                    ds.drive_configuration_id, 
                    ds.commission_earned,                    (SELECT COUNT(*) FROM drive_orders WHERE session_id = ds.id) AS tasks_in_configuration,
                    (SELECT COUNT(*) FROM drive_orders WHERE session_id = ds.id AND status = 'completed') AS tasks_completed_count
                 FROM drive_sessions ds
                 WHERE ds.id = $1`,
                [activeSessionId]
            );

            if (sessionDetailsResult.rows.length === 0) {
                 // Should not happen if existingSession found it
                logger.error(`Active session ${activeSessionId} found but details could not be retrieved for user ID: ${userId}.`); // Added error log
                return res.status(404).json({ message: 'Active session found but details could not be retrieved.' });
            }
            
            const sessionDetails = sessionDetailsResult.rows[0];            const firstOrderResult = await pool.query(
                `SELECT drv_ord.id, drv_ord.product_id, drv_ord.order_in_drive, drv_ord.status,
                        p.name AS product_name, p.price AS product_price, p.image_url AS product_image_url, p.description AS product_description
                 FROM drive_orders drv_ord
                 JOIN products p ON drv_ord.product_id = p.id
                 WHERE drv_ord.session_id = $1 AND drv_ord.status = 'pending'
                 ORDER BY drv_ord.order_in_drive ASC
                 LIMIT 1`,
                [activeSessionId]
            );

            return res.status(200).json({
                message: 'Active drive session already exists.',
                drive_session_id: sessionDetails.drive_session_id,
                drive_configuration_id: sessionDetails.drive_configuration_id,
                first_order: firstOrderResult.rows.length > 0 ? firstOrderResult.rows[0] : null,
                tasks_in_configuration: parseInt(sessionDetails.tasks_in_configuration, 10),
                tasks_completed: parseInt(sessionDetails.tasks_completed_count, 10),
                total_session_commission: parseFloat(sessionDetails.commission_earned)
            });
        }

        // Find an active drive configuration (e.g., the latest one or based on some criteria)
        // For simplicity, let's pick the one with the lowest ID that is active.
        // This could be made more sophisticated (e.g., admin-designated default, or user choice)
        logger.debug(`No active session found for user ID: ${userId}. Attempting to create a new one.`); // Added debug log
        logger.debug(`Fetching active drive configuration.`); // Added debug log
        const activeConfigurationResult = await pool.query(
            'SELECT id, name FROM drive_configurations WHERE is_active = TRUE ORDER BY id ASC LIMIT 1'
        );

        if (activeConfigurationResult.rows.length === 0) {
            logger.warn('No active drive configurations found in the system.'); // Changed to warn
            return res.status(404).json({ message: 'No active drive configurations found.' });
        }
        const activeConfiguration = activeConfigurationResult.rows[0];
        logger.debug(`Using drive configuration ID: ${activeConfiguration.id}, Name: ${activeConfiguration.name}`); // Added debug log

        // Get products for this configuration
        logger.debug(`Fetching products for configuration ID: ${activeConfiguration.id}`); // Added debug log
        const configItemsResult = await pool.query(
            'SELECT product_id, order_in_drive FROM drive_configuration_items WHERE drive_configuration_id = $1 ORDER BY order_in_drive ASC',
            [activeConfiguration.id]
        );

        if (configItemsResult.rows.length === 0) {
            logger.warn(`Drive configuration ID: ${activeConfiguration.id} has no products.`); // Changed to warn
            return res.status(400).json({ message: 'Selected drive configuration has no products.' });
        }
        const tasksRequired = configItemsResult.rows.length;

        // Start a new drive session
        const driveSessionResult = await pool.query(
            'INSERT INTO drive_sessions (user_id, drive_configuration_id, status, tasks_required, commission_earned, started_at) VALUES ($1, $2, \'active\', $3, 0, NOW()) RETURNING id, started_at',
            [userId, activeConfiguration.id, tasksRequired]
        );
        const driveSessionId = driveSessionResult.rows[0].id;
        logger.info(`New drive session ${driveSessionId} created for user ID: ${userId} with configuration ID: ${activeConfiguration.id}`); // Changed to info

        // Create drive_orders for this session
        const productOrders = configItemsResult.rows;
        logger.debug(`Creating ${productOrders.length} drive orders for session ID: ${driveSessionId}`); // Added debug log
        for (const item of productOrders) {
            await pool.query(
                'INSERT INTO drive_orders (session_id, product_id, order_in_drive, status) VALUES ($1, $2, $3, \'pending\')',
                [driveSessionId, item.product_id, item.order_in_drive]
            );
        }

        // Fetch the first order to return to the client
        logger.debug(`Fetching first order for session ID: ${driveSessionId}`); // Added debug log        const firstOrderResult = await pool.query(
            `SELECT drv_ord.id, drv_ord.product_id, drv_ord.order_in_drive, drv_ord.status,
                    p.name AS product_name, p.price AS product_price, p.image_url AS product_image_url, p.description AS product_description
             FROM drive_orders drv_ord
             JOIN products p ON drv_ord.product_id = p.id
             WHERE drv_ord.session_id = $1
             ORDER BY drv_ord.order_in_drive ASC
             LIMIT 1`,
            [driveSessionId]
        );
        
        const firstOrder = firstOrderResult.rows.length > 0 ? firstOrderResult.rows[0] : null;

        res.status(201).json({
            message: 'Drive started successfully.',
            drive_session_id: driveSessionId,
            drive_configuration_id: activeConfiguration.id,
            first_order: firstOrder, // Send the first order
            tasks_in_configuration: tasksRequired, // Send total tasks count
            tasks_completed: 0, // Initially 0 tasks completed
            total_session_commission: 0 // Initially 0 commission
        });
        logger.debug(`startDrive completed successfully for user ID: ${userId}, session ID: ${driveSessionId}`); // Added debug log

    } catch (error) {
        logger.error(`Error in startDrive for user ID: ${userId} - ${error.message}`, { stack: error.stack }); // Enhanced error log
        res.status(500).json({ message: 'Failed to start drive', error: error.message });
    }
};

const getDriveStatus = async (req, res) => {
  const userId = req.user.id;
  logger.debug(`Entering getDriveStatus for user ID: ${userId}`); // Added debug log
  try {
    // First check for ANY active, pending_reset, or frozen session
    logger.debug(`Fetching current session status for user ID: ${userId}`); // Added debug log
    const sessionResult = await pool.query(
      `SELECT id, status, tasks_completed, tasks_required, frozen_amount_needed
       FROM drive_sessions
       WHERE user_id = $1 AND status IN ('active', 'pending_reset', 'frozen')
       ORDER BY started_at DESC LIMIT 1`,
      [userId]
    );
    
    if (sessionResult.rows.length === 0) {
      logger.debug(`No active, pending_reset, or frozen session found for user ID: ${userId}.`); // Added debug log
      return res.json({ code: 0, status: 'no_session' });
    }

    const session = sessionResult.rows[0];
    const sessionId = session.id;
    logger.debug(`Session ID: ${sessionId} found with status: ${session.status} for user ID: ${userId}`); // Added debug log
    
    // Calculate total commission earned in this drive
    logger.debug(`Calculating total commission for session ID: ${sessionId}`); // Added debug log
    const commissionResult = await pool.query(
      `SELECT COALESCE(SUM(commission_amount), 0) as total_commission
       FROM commission_logs
       WHERE user_id = $1 
       AND commission_type = 'data_drive'
       AND reference_id IN (
         SELECT DISTINCT reference_id FROM commission_logs 
         WHERE source_action_id IN (
           SELECT product_id FROM drive_orders WHERE session_id = $2
         )
       )`,
      [userId, sessionId]
    );
    
    const totalCommission = parseFloat(commissionResult.rows[0]?.total_commission || 0);
    logger.debug(`Total commission for session ID: ${sessionId} is ${totalCommission}`); // Added debug log
    
    if (session.status === 'pending_reset') {
      logger.info(`Session ID: ${sessionId} is pending_reset for user ID: ${userId}.`); // Changed to info
      return res.json({ 
        code: 0, 
        status: 'complete',
        tasks_completed: session.tasks_completed,
        tasks_required: session.tasks_required,
        total_commission: totalCommission.toFixed(2),
        info: 'Drive completed. Pending admin reset.'
      });
    }
      if (session.status === 'frozen') {
        logger.info(`Session ID: ${sessionId} is frozen for user ID: ${userId}. Amount needed: ${session.frozen_amount_needed}`); // Changed to info
        return res.json({ 
        code: 0, 
        status: 'frozen',
        tasks_completed: session.tasks_completed,
        tasks_required: session.tasks_required,
        total_commission: totalCommission.toFixed(2),
        frozen_amount_needed: session.frozen_amount_needed,
        info: 'Drive frozen due to insufficient balance. Please deposit funds.'
      });
    }

    // Look for ANY incomplete order (either current or pending)
    const incompleteOrderResult = await pool.query(
      `SELECT drv_ord.id AS order_id, drv_ord.status AS order_status, 
              p.id AS product_id, p.name AS product_name, 
              p.image_url AS product_image, p.price AS product_price
       FROM drive_orders drv_ord
       JOIN products p ON drv_ord.product_id = p.id
       WHERE drv_ord.session_id = $1 
       AND drv_ord.status IN ('current', 'pending')
       ORDER BY CASE 
         WHEN drv_ord.status = 'current' THEN 0 
         WHEN drv_ord.status = 'pending' THEN 1 
       END, drv_ord.id ASC
       LIMIT 1`,
      [sessionId]
    );
    if (incompleteOrderResult.rows.length > 0) {
      const incompleteOrder = incompleteOrderResult.rows[0];
      const { tier } = await getUserDriveInfo(userId);
      const commission = calculateCommission(parseFloat(incompleteOrder.product_price), tier, 'single');

      // Calculate total commission earned in this drive
      const commissionResult = await pool.query(
        `SELECT COALESCE(SUM(commission_amount), 0) as total_commission
         FROM commission_logs
         WHERE user_id = $1 
         AND commission_type = 'data_drive'
         AND drive_session_id = $2`,
        [userId, sessionId]
      );
      
      const totalCommission = parseFloat(commissionResult.rows[0]?.total_commission || 0);
      // If order was pending, set it to current
      if (incompleteOrder.order_status === 'pending') {
        await pool.query(
          `UPDATE drive_orders SET status = 'current' WHERE id = $1`,
          [incompleteOrder.order_id]
        );
        incompleteOrder.order_status = 'current';
      }

      return res.json({
        code: 0,
        status: 'active',
        tasks_completed: session.tasks_completed,
        tasks_required: session.tasks_required,
        total_commission: totalCommission.toFixed(2),
        current_order: {
          order_id: incompleteOrder.order_id,
          product_id: incompleteOrder.product_id,
          product_name: incompleteOrder.product_name,
          product_image: incompleteOrder.product_image || './assets/uploads/products/newegg-1.jpg',
          product_price: parseFloat(incompleteOrder.product_price),
          order_commission: commission,
          fund_amount: parseFloat(incompleteOrder.product_price),
          premium_status: 0,
          product_number: uuidv4().substring(0, 18)
        }
      });
    }

    // If no incomplete orders, mark the drive as complete
    await pool.query(
      `UPDATE drive_sessions SET status = 'pending_reset', completed_at = NOW() WHERE id = $1`,
      [sessionId]
    );

    return res.json({ 
      code: 0, 
      status: 'complete', 
      tasks_completed: session.tasks_completed,
      tasks_required: session.tasks_required,
      info: 'Drive completed successfully. Please wait for admin reset.'
    });

  } catch (error) {
    logger.error('Error getting drive status:', error);
    res.status(500).json({ code: 1, info: 'Server error getting drive status: ' + error.message });
  }
};

const getOrder = async (req, res) => {
    const userId = req.user.id;
    const { drive_session_id: session_id, current_order_id } = req.body;
    logger.debug(`Entering getOrder for user ID: ${userId}, session ID: ${session_id}, current order ID: ${current_order_id}`); // Added debug log

    if (!session_id) {
        logger.warn(`getOrder called without session_id for user ID: ${userId}`); // Changed to warn
        return res.status(400).json({ message: "Drive session ID is required." });
    }

    try {
        // Verify the session belongs to the user and is active
        logger.debug(`Verifying session ${session_id} for user ID: ${userId}`); // Added debug log
        const sessionResult = await pool.query(
            'SELECT status FROM drive_sessions WHERE id = $1 AND user_id = $2',
            [session_id, userId]
        );

        if (sessionResult.rows.length === 0) {
            logger.warn(`Drive session ${session_id} not found or does not belong to user ID: ${userId}`); // Changed to warn
            return res.status(404).json({ message: "Drive session not found or access denied." });
        }
        if (sessionResult.rows[0].status !== 'active') {
            logger.warn(`Drive session ${session_id} is not active (status: ${sessionResult.rows[0].status}) for user ID: ${userId}`); // Changed to warn
            return res.status(403).json({ message: `Drive session is not active. Current status: ${sessionResult.rows[0].status}` });
        }

        // Fetch the next pending order for the given drive session
        logger.debug(`Fetching next pending order for session ID: ${session_id}`); // Added debug log
        const nextOrderResult = await pool.query(
            `SELECT do.id, do.product_id, do.order_in_drive, do.status,
                    p.name AS product_name, p.price AS product_price, p.image_url AS product_image_url, p.description AS product_description
             FROM drive_orders do
             JOIN products p ON do.product_id = p.id
             WHERE do.session_id = $1 AND do.status = 'pending'
             ORDER BY do.order_in_drive ASC
             LIMIT 1`,
            [session_id]
        );
        
        if (nextOrderResult.rows.length === 0) {
            // This might mean all orders are completed, or an issue if current_order_id was the last one but not marked.
            // Or, it could be that the drive is now complete.
            logger.info(`No more pending orders found for session ID: ${session_id}. This might indicate drive completion.`); // Changed to info
            return res.status(200).json({ message: "No more pending orders in this drive session. It might be complete.", next_order: null });
        }
        
        const retrievedOrder = nextOrderResult.rows[0];
        logger.debug(`Next order ID: ${retrievedOrder.id} (Product ID: ${retrievedOrder.product_id}) found for session ID: ${session_id}`); // Added debug log
        
        res.status(200).json({
            message: "Next order retrieved successfully.",
            next_order: retrievedOrder
        });

    } catch (error) {
        logger.error(`Error in getOrder for session ID: ${session_id}, user ID: ${userId} - ${error.message}`, { stack: error.stack }); // Enhanced error log
        res.status(500).json({ message: "Failed to get next order.", error: error.message });
    }
};


const saveOrder = async (req, res) => {
    const userId = req.user.id;
    const { drive_session_id, drive_order_id, product_id, tasks_completed_count, tasks_in_configuration } = req.body;
    logger.debug(`Entering saveOrder for user ID: ${userId}, session ID: ${drive_session_id}, order ID: ${drive_order_id}, product ID: ${product_id}`); // Added debug log

    if (!drive_session_id || !drive_order_id || !product_id) {
        logger.warn(`saveOrder called with missing parameters for user ID: ${userId}. Session: ${drive_session_id}, Order: ${drive_order_id}, Product: ${product_id}`); // Changed to warn
        return res.status(400).json({ message: "Missing required parameters (drive_session_id, drive_order_id, product_id)." });
    }

    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        logger.debug(`Transaction started for saveOrder, session ID: ${drive_session_id}, order ID: ${drive_order_id}`); // Added debug log

        // Verify the drive order and session
        logger.debug(`Verifying drive order ${drive_order_id} for session ${drive_session_id} and user ${userId}`); // Added debug log
        const orderResult = await client.query(
            `SELECT do.id, do.status as order_status, ds.status as session_status, ds.user_id, ds.drive_configuration_id, ds.tasks_required, ds.tasks_completed, ds.commission_earned as session_commission_earned,
                    p.price as product_price, p.commission_rate as product_commission_rate, u.tier as user_tier
             FROM drive_orders do
             JOIN drive_sessions ds ON do.session_id = ds.id
             JOIN products p ON do.product_id = p.id
             JOIN users u ON ds.user_id = u.id
             WHERE do.id = $1 AND do.session_id = $2 AND do.product_id = $3 AND ds.user_id = $4`,
            [drive_order_id, drive_session_id, product_id, userId]
        );

        if (orderResult.rows.length === 0) {
            await client.query('ROLLBACK');
            logger.warn(`Order ${drive_order_id} not found or mismatched for session ${drive_session_id}, product ${product_id}, user ${userId}.`); // Changed to warn
            return res.status(404).json({ message: "Drive order not found, or does not match session/product, or access denied." });
        }

        const orderData = orderResult.rows[0];

        if (orderData.session_status !== 'active') {
            await client.query('ROLLBACK');
            logger.warn(`Attempt to save order ${drive_order_id} for a non-active session ${drive_session_id} (status: ${orderData.session_status}).`); // Changed to warn
            return res.status(403).json({ message: `Cannot save order, drive session is not active. Status: ${orderData.session_status}` });
        }

        if (orderData.order_status === 'completed') {
            // If already completed, just return success with current state. This can happen with retries or refreshes.
            // Fetch the next pending order to help client continue
            logger.info(`Order ${drive_order_id} is already marked as completed for session ${drive_session_id}.`); // Changed to info
            const nextPendingOrderResult = await client.query(
                `SELECT do.id, do.product_id, do.order_in_drive, do.status,
                        p.name AS product_name, p.price AS product_price, p.image_url AS product_image_url, p.description AS product_description
                 FROM drive_orders do
                 JOIN products p ON do.product_id = p.id
                 WHERE do.session_id = $1 AND do.status = 'pending'
                 ORDER BY do.order_in_drive ASC
                 LIMIT 1`,
                [drive_session_id]
            );
            const nextPendingOrder = nextPendingOrderResult.rows.length > 0 ? nextPendingOrderResult.rows[0] : null;
            const updatedTasksCompleted = orderData.tasks_completed; // Use existing completed count

            await client.query('COMMIT'); // Commit as no changes were made, but we are returning a valid state.
            return res.status(200).json({
                message: "Order already completed.",
                order_status: 'completed',
                drive_session_id: drive_session_id,
                next_order: nextPendingOrder,
                tasks_completed: updatedTasksCompleted,
                tasks_in_configuration: orderData.tasks_required,
                total_session_commission: parseFloat(orderData.session_commission_earned) // Return existing session commission
            });
        }

        // Mark the order as completed
        logger.debug(`Marking order ${drive_order_id} as completed for session ${drive_session_id}.`); // Added debug log
        await client.query(
            'UPDATE drive_orders SET status = \'completed\', completed_at = NOW() WHERE id = $1',
            [drive_order_id]
        );

        // Calculate commission for this specific order
        const orderCommission = parseFloat(orderData.product_price) * (parseFloat(orderData.product_commission_rate) / 100);
        logger.debug(`Calculated commission for order ${drive_order_id}: ${orderCommission}`); // Added debug log

        // Update user's main balance
        logger.debug(`Updating main balance for user ${userId} by ${orderCommission}`); // Added debug log
        await client.query(
            'UPDATE accounts SET balance = balance + $1 WHERE user_id = $2 AND type = \'main\'',
            [orderCommission, userId]
        );

        // Log the commission
        const commissionLogId = uuidv4();
        logger.debug(`Logging commission (ID: ${commissionLogId}) for user ${userId}, order ${drive_order_id}, amount ${orderCommission}`); // Added debug log
        await client.query(
            'INSERT INTO commission_logs (id, user_id, amount, type, description, product_id, drive_order_id, drive_session_id, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())',
            [commissionLogId, userId, orderCommission, 'drive_product_completion', `Commission for completing product ${product_id} in drive ${drive_session_id}`, product_id, drive_order_id, drive_session_id]
        );

        // Update the drive session: increment tasks_completed and add to commission_earned
        logger.debug(`Updating drive session ${drive_session_id}: incrementing tasks_completed and commission_earned by ${orderCommission}`); // Added debug log
        const updatedSessionResult = await client.query(
            'UPDATE drive_sessions SET tasks_completed = tasks_completed + 1, commission_earned = commission_earned + $1 WHERE id = $2 RETURNING tasks_completed, commission_earned, tasks_required',
            [orderCommission, drive_session_id]
        );
        const updatedSessionData = updatedSessionResult.rows[0];
        const currentTasksCompleted = updatedSessionData.tasks_completed;
        const currentSessionCommission = parseFloat(updatedSessionData.commission_earned);

        // Initialize nextPendingOrder variable for the response
        let nextPendingOrder = null;
        logger.debug(`Initialized nextPendingOrder as null for drive session ${drive_session_id}`);
        let sessionStatus = 'active';

        if (currentTasksCompleted >= orderData.tasks_required) {
            // All tasks for this drive session are completed
            logger.info(`All ${orderData.tasks_required} tasks completed for drive session ${drive_session_id}. Marking session as completed.`); // Changed to info
            await client.query(
                'UPDATE drive_sessions SET status = \'completed\', completed_at = NOW() WHERE id = $1',
                [drive_session_id]
            );
            sessionStatus = 'completed';
            // Optionally, log a final drive completion event or trigger other processes
            logDriveOperation(userId, drive_session_id, 'drive_completed', `Drive session completed with ${currentTasksCompleted} tasks and total commission ${currentSessionCommission}.`);

        } else {
            // Fetch the next pending order
            logger.debug(`Fetching next pending order for session ${drive_session_id} as not all tasks are complete yet (${currentTasksCompleted}/${orderData.tasks_required})`); // Added debug log
            const nextPendingOrderResult = await client.query(
                `SELECT do.id, do.product_id, do.order_in_drive, do.status,
                        p.name AS product_name, p.price AS product_price, p.image_url AS product_image_url, p.description AS product_description
                 FROM drive_orders do
                 JOIN products p ON do.product_id = p.id
                 WHERE do.session_id = $1 AND do.status = 'pending'
                 ORDER BY do.order_in_drive ASC
                 LIMIT 1`,
                [drive_session_id]
            );
            if (nextPendingOrderResult.rows.length > 0) {
                nextPendingOrder = nextPendingOrderResult.rows[0];
                logger.debug(`Next order ID: ${nextPendingOrder.id} found for session ${drive_session_id}`); // Added debug log
            } else {
                // This case should ideally not be hit if currentTasksCompleted < tasks_required
                // but as a safeguard:
                logger.warn(`Session ${drive_session_id} not yet complete (${currentTasksCompleted}/${orderData.tasks_required}), but no next pending order found. This might indicate an issue.`); // Changed to warn
            }
        }
        await client.query('COMMIT');
        logger.debug(`Transaction committed for saveOrder, session ID: ${drive_session_id}, order ID: ${drive_order_id}`); // Added debug log
        
        res.status(200).json({
            message: "Order saved successfully.",
            order_status: 'completed',
            drive_session_id: drive_session_id,
            drive_session_status: sessionStatus, // 'active' or 'completed'
            next_order: nextPendingOrder,
            tasks_completed: currentTasksCompleted,
            tasks_in_configuration: orderData.tasks_required,
            order_commission: orderCommission, // Commission for this specific order
            total_session_commission: currentSessionCommission // Updated total commission for the session
        });
    } catch (error) {
        // Log the error and roll back transaction
        await client.query('ROLLBACK');
        logger.error(`Error in saveOrder for session ${drive_session_id}, order ${drive_order_id}, user ${userId} - ${error.message}`, { stack: error.stack }); // Enhanced error log
        res.status(500).json({ message: "Failed to save order.", error: error.message });
    } finally {
        client.release();
        logger.debug(`Client released for saveOrder, session ID: ${drive_session_id}, order ID: ${drive_order_id}`); // Added debug log
    }
};

const saveComboOrder = async (req, res) => {
  // ...unchanged, omitted for brevity...
  res.json({ success: true, info: 'Combo order completed!' });
};

const saveComboProduct = async (req, res) => {
  // ...unchanged, omitted for brevity...
  res.json({ code: 0, info: 'Combo product saved successfully!' });
};

const getDriveOrders = async (req, res) => {
  const userId = req.user.id;
  const { statusFilter } = req.body;
  try {
    const sessionResult = await pool.query(
      `SELECT id, status
       FROM drive_sessions
       WHERE user_id = $1 AND status IN ('active', 'frozen', 'pending_reset')
       ORDER BY started_at DESC LIMIT 1`,
      [userId]
    );
    if (sessionResult.rows.length === 0)
      return res.status(400).json({ code: 1, info: 'No active or completed drive session found.' });
    
    const session = sessionResult.rows[0];
    const sessionId = session.id;
    const sessionStatus = session.status;
    
    let query = `
      SELECT
        drv_orders.id AS order_id,
        drv_orders.status AS order_status,
        p.id AS product_id,
        p.name AS product_name,
        p.image_url AS product_image,
        p.price AS product_price
      FROM drive_orders drv_orders
      JOIN products p ON drv_orders.product_id = p.id
      WHERE drv_orders.session_id = $1
    `;
    
    const queryParams = [sessionId];
    
    if (statusFilter && statusFilter !== 'all') {
      if (statusFilter === 'frozen') {
        if (sessionStatus !== 'frozen') return res.json({ code: 0, orders: [] });
      } else if (statusFilter === 'pending') {
         query += ` AND drv_orders.status = 'current'`; // Show current order in pending tab
      } else {
        query += ` AND drv_orders.status = $2`;
        queryParams.push(statusFilter);
      }
    } else if (statusFilter === 'all') {
        // For completed drive (pending_reset), show all completed orders
        if (sessionStatus === 'pending_reset') {
            query += ` AND drv_orders.status = 'completed'`;
        } else {
            // For active drive, show completed orders plus current order
            query += ` AND drv_orders.status IN ('current', 'completed')`;
        }
    }

    query += ` ORDER BY 
      CASE 
        WHEN drv_orders.status = 'current' THEN 0
        ELSE 1
      END,
      drv_orders.id ASC`;
    
    const ordersResult = await pool.query(query, queryParams);
    const orders = ordersResult.rows.map(order => ({
      order_id: order.order_id,
      product_id: order.product_id,
      product_name: order.product_name,
      product_image: order.product_image || './assets/uploads/products/newegg-1.jpg',
      product_price: parseFloat(order.product_price).toFixed(2),
      order_status: sessionStatus === 'frozen' ? 'frozen' : order.order_status
    }));

    res.json({ code: 0, orders });
  } catch (error) {
    res.status(500).json({ code: 1, info: 'Server error getting drive orders: ' + error.message });
  }
};

/**
 * Get user's drive progress for dashboard display
 */
const getDriveProgress = async (req, res) => {
  const userId = req.user.id;
  try {
    // Check and potentially reset weekly progress
    await driveProgressService.checkAndResetWeeklyProgress(userId);
    
    // Get the user's drive progress data
    const progressData = await driveProgressService.getUserDriveProgress(userId);
    
    // Format the response
    res.json({
      code: 0,
      today: {
        drives_completed: progressData.today.drives_completed || 0,
        is_working_day: progressData.today.is_working_day || false
      },
      weekly: {
        progress: progressData.overall.weekly_progress || 0,
        total: 7 // Always 7 days in a week
      },
      total_working_days: progressData.overall.total_working_days || 0
    });
  } catch (error) {
    logger.error(`Error getting drive progress: ${error.message}`, { userId, error });
    res.status(500).json({ 
      code: 1, 
      info: 'Error retrieving drive progress data: ' + error.message 
    });
  }
};

const getActiveDriveSessionDetails = async (req, res) => {
    const userId = req.user.id;
    try {
        const activeSessionResult = await pool.query(
            `SELECT 
                ds.id AS drive_session_id, 
                ds.drive_configuration_id, 
                ds.status,
                ds.tasks_required AS tasks_in_configuration,
                ds.commission_earned AS total_session_commission,
                (SELECT COUNT(*) FROM drive_orders WHERE session_id = ds.id AND status = 'completed') AS tasks_completed_count
             FROM drive_sessions ds
             WHERE ds.user_id = $1 AND ds.status = 'active'`,
            [userId]
        );

        if (activeSessionResult.rows.length === 0) {
            return res.json({ active_session: false, message: 'No active drive session found.' });
        }

        const sessionDetails = activeSessionResult.rows[0];
        
        // Fetch the current pending order for this active session
        const currentOrderResult = await pool.query(
            `SELECT do.id, do.product_id, do.order_in_drive, do.status,
                    p.name AS product_name, p.price AS product_price, p.image_url AS product_image_url, p.description AS product_description
             FROM drive_orders do
             JOIN products p ON do.product_id = p.id
             WHERE do.session_id = $1 AND do.status = 'pending'
             ORDER BY do.order_in_drive ASC
             LIMIT 1`,
            [sessionDetails.drive_session_id]
        );

        const currentOrder = currentOrderResult.rows.length > 0 ? currentOrderResult.rows[0] : null;

        res.json({
            active_session: true,
            drive_session_id: sessionDetails.drive_session_id,
            drive_configuration_id: sessionDetails.drive_configuration_id,
            current_order: currentOrder,
            tasks_in_configuration: parseInt(sessionDetails.tasks_in_configuration, 10),
            tasks_completed: parseInt(sessionDetails.tasks_completed_count, 10),
            total_session_commission: parseFloat(sessionDetails.total_session_commission)
        });

    } catch (error) {
        console.error('Error fetching active drive session details:', error);
        res.status(500).json({ message: 'Failed to fetch active drive session details', error: error.message });
    }
};

module.exports = {
    startDrive,
    saveOrder,
    getOrder,
    saveComboOrder,
    saveComboProduct,
    getDriveOrders,
    getDriveStatus,
    getDriveProgress,
    getActiveDriveSessionDetails // Add new function to exports
};
